# kmodlike - Обзор программы

## Описание

`kmodlike` - это минимальный рабочий пример программы для динамической загрузки и управления модулями (shared libraries) с использованием RPC интерфейса. Программа демонстрирует механизм загрузки модулей, обработку ошибок (включая SIGSEGV) и удаленное управление через RPC.

## ИДЕЯ МОДУЛЯ: Все что может умереть, должно умирать отдельно от всего остального.

## Архитектура

kmodlike/
├── module_loader.c      (логика загрузки модулей, структура состояния)
├── module_loader.h      (публичный API загрузки модулей)
├── module_error.h       (типизированные коды ошибок)
├── main.c               (демон, основной цикл, инициализация)
├── rpc_commands.c       (RPC команды для работы с модулями)
├── rpc.c                (RPC сервер и клиент)
├── rpc.h                (интерфейс RPC)
├── mod.c                (пример модуля)
├── mod.h                (интерфейс модуля)
├── tests/
│   ├── test_module_loader.c   (unit тесты загрузки)
│   ├── test_crash_recovery.c  (интеграционный тест падений)
│   └── fixtures/
│       ├── test_mod_good.c    (корректный модуль)
│       ├── test_mod_no_init.c (модуль без mod_init)
│       └── test_mod_bad_init.c (модуль с mod_init возвращающим ошибку)
├── Makefile             (сборка программы, модуля, библиотеки, тестов)
└── overview.md          (документация)

### Основная программа (kmodlike)

Основная программа может работать в двух режимах:

1. **Режим демона (daemon mode)** - запускается без аргументов:
   - Инициализирует RPC сервер на порту 8888
   - Регистрирует RPC команды: `insmod`, `rmmod`, `help`
   - В основном цикле каждую секунду пытается вызвать функцию `mod_hello()` из загруженного модуля
   - Если модуль не загружен, выводит "module not_loaded"
   - Обрабатывает SIGSEGV от модуля и автоматически выгружает модуль без падения программы

2. **Режим клиента (client mode)** - запускается с аргументами `insmod` или `rmmod`:
   - Работает как RPC клиент
   - Подключается к демону на localhost:8888
   - Отправляет RPC запрос на загрузку/выгрузку модуля
   - Выводит результат и завершается

### Модуль (mod.so)

Динамически загружаемая библиотека (`mod.so`), которая:

- Экспортирует функцию `mod_hello()`, которая печатает "hello world" на экран
- При загрузке (через `__attribute__((constructor))`) запускает отдельный поток
- Через 3 секунды после загрузки намеренно провоцирует SIGSEGV через разыменование NULL указателя

## Файлы проекта

### main.c / main.h
Основная программа с функциями:
- `module_load()` - загрузка модуля через `dlopen()`
  - Проверяет наличие обязательных функций `mod_init()` и `mod_fini()`
  - Вызывает `mod_init()` после успешной загрузки
  - Валидирует минимальный интерфейс модуля перед загрузкой
- `module_unload()` - выгрузка модуля через `dlclose()`
  - Вызывает `mod_fini()` перед выгрузкой для очистки ресурсов
- `module_call_hello()` - вызов функции из модуля
- `module_get_state()` - получение состояния модуля
- `sigsegv_handler()` - обработчик SIGSEGV
- RPC команды: `rpc_insmod_func()`, `rpc_rmmod_func()`

### mod.c / mod.h
Модуль с минимальным интерфейсом (аналогично модулям ядра Linux):
- **Обязательные функции:**
  - `mod_init()` - функция инициализации модуля (аналог `init_module` в ядре)
    - Вызывается явно основной программой после загрузки модуля
    - Возвращает 0 при успехе, отрицательное значение при ошибке
    - Создает поток, который через 3 секунды вызывает SIGSEGV
  - `mod_fini()` - функция деинициализации модуля (аналог `cleanup_module` в ядре)
    - Вызывается явно основной программой перед выгрузкой модуля
    - Завершает все потоки и освобождает ресурсы
- **Опциональные функции:**
  - `mod_hello()` - экспортируемая функция, печатающая "hello world"

### rpc.c / rpc.h
RPC библиотека для обмена командами между клиентом и сервером:
- UDP сокетный интерфейс
- Порт по умолчанию: 8888
- Формат запроса: null-terminated строки

### Makefile
Содержит цели:
- `make bin` - сборка основной программы
- `make mod` - сборка модуля
- `make all` - сборка всего
- `make clean` - очистка

## Использование

### Запуск демона

```bash
./kmodlike
```

Демон запустится и будет слушать RPC запросы на порту 8888.

### Загрузка модуля (через RPC)

```bash
./kmodlike insmod mod.so
```

Эта команда:
1. Запускается как копия программы в режиме RPC клиента
2. Подключается к демону по UDP на localhost:8888
3. Отправляет команду `insmod mod.so`
4. Демон загружает модуль через `dlopen()`
5. Клиент получает ответ и завершается

### Выгрузка модуля (через RPC)

```bash
./kmodlike rmmod mod
```

Аналогично команде `insmod`, но выполняет выгрузку модуля.

## Workflow

### Нормальный сценарий

1. Запуск демона: `./kmodlike`
2. Загрузка модуля: `./kmodlike insmod mod.so`
3. В основном цикле демона каждую секунду вызывается `mod_hello()` и выводится "hello world"
4. Через 3 секунды модуль вызывает SIGSEGV
5. Обработчик SIGSEGV устанавливает флаг
6. В основном цикле обнаруживается флаг, модуль выгружается
7. Демон продолжает работу, выводя "module not_loaded"

### Интеграционный тест

```bash
make clean
make all
./kmodlike insmod mod.so
# Ждем 3 hello world, потом сообщение о выгрузке модуля
./kmodlike insmod mod.so
# Снова ждем hello world
./kmodlike rmmod mod
# Модуль выгружается
```

## Архитектура модулей

### Стабильный интерфейс модуля

Архитектура модулей использует версионированный интерфейс, определенный в `module_interface.h`. Каждый модуль должен реализовать обязательные функции интерфейса.

#### Обязательные функции:

1. **`uint32_t module_get_interface_version(void)`** - версия интерфейса модуля
   - Должна возвращать `MODULE_INTERFACE_VERSION_CURRENT`
   - Используется загрузчиком для проверки совместимости версий
   - Модули с несовместимой версией будут отклонены

2. **`int module_init(const void *init_args)`** - функция инициализации
   - Вызывается основной программой после загрузки модуля
   - Принимает указатель на структуру `module_init_args_t` или NULL
   - Структура содержит версию, функции логирования, получения времени и пользовательские данные
   - Должна выполнить всю необходимую инициализацию
   - Возвращает `0` при успехе, отрицательное значение при ошибке
   - Если возвращает ошибку, модуль не считается загруженным

3. **`void module_fini(void)`** - функция деинициализации
   - Вызывается основной программой перед выгрузкой модуля
   - Должна завершить все потоки и освободить все ресурсы
   - Модуль не будет выгружен, пока эта функция не завершится

#### Опциональные функции:

- Любые модуль-специфичные функции могут быть экспортированы и доступны через `module_loader_get_symbol()`
- Legacy функция `mod_hello()` поддерживается для обратной совместимости

### Структура аргументов инициализации

```c
typedef struct {
    uint32_t version;                    // версия структуры
    void (*log)(int, const char *, ...); // функция логирования
    int (*get_time)(struct timespec *);  // функция получения времени
    void *user_data;                     // пользовательские данные
} module_init_args_t;
```

### Процесс загрузки модуля:

1. Вызов `dlopen()` - загрузка библиотеки в память
2. Проверка версии интерфейса через `module_get_interface_version()`
3. Проверка наличия обязательных функций через `dlsym()`
4. Вызов `module_init(init_args)` для инициализации модуля с передачей аргументов
5. Если `module_init()` вернул ошибку, модуль выгружается

### Процесс выгрузки модуля:

1. Вызов `module_fini()` для очистки ресурсов
2. Ожидание завершения всех потоков модуля (через `pthread_join()`)
3. Вызов `dlclose()` для выгрузки библиотеки

### Версионирование интерфейса

Интерфейс использует версионирование для обеспечения совместимости и возможности будущих расширений без breaking changes. Модули должны возвращать актуальную версию интерфейса из `module_get_interface_version()`.

## Технические детали

### Обработка SIGSEGV

- При получении SIGSEGV устанавливается атомарный флаг `g_sigsegv_received`
- В основном цикле проверяется флаг, и если он установлен, модуль выгружается
- Основная программа не падает, продолжает работу

### Потокобезопасность

- Используется единый паттерн синхронизации: все операции с состоянием модуля защищены `pthread_mutex_t`
- Reference counting (`ref_count`) защищен mutex, используется обычная переменная типа `int`
- Флаг состояния `loaded` защищен mutex, используется обычная переменная типа `bool`
- Все операции загрузки, выгрузки, получения символов выполняются под одной блокировкой mutex
- RPC сервер работает в отдельном потоке, доступ к глобальному контексту защищен mutex
- Модули должны корректно завершать все потоки в `module_fini()`

### RPC протокол

- UDP сокеты для простоты
- Формат запроса: null-terminated строки (первая - команда, следующие - аргументы)
- Ответ - строка с результатом операции

## Ограничения

- Работает только с одним модулем одновременно
- RPC сервер работает только на localhost
- Нет аутентификации и авторизации в RPC

