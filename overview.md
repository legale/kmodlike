# kmodlike - Обзор программы

## Описание

`kmodlike` - это минимальный рабочий пример программы для динамической загрузки и управления модулями (shared libraries) с использованием RPC интерфейса. Программа демонстрирует механизм загрузки модулей, обработку ошибок (включая SIGSEGV) и удаленное управление через RPC.

## Архитектура

kmodlike/
├── module_loader.c      (логика загрузки модулей, структура состояния)
├── module_loader.h      (публичный API загрузки модулей)
├── module_error.h       (типизированные коды ошибок)
├── main.c               (демон, основной цикл, инициализация)
├── rpc_commands.c       (RPC команды для работы с модулями)
├── rpc.c                (RPC сервер и клиент)
├── rpc.h                (интерфейс RPC)
├── mod.c                (пример модуля)
├── mod.h                (интерфейс модуля)
├── tests/
│   ├── test_module_loader.c   (unit тесты загрузки)
│   ├── test_crash_recovery.c  (интеграционный тест падений)
│   └── fixtures/
│       ├── test_mod_good.c    (корректный модуль)
│       ├── test_mod_no_init.c (модуль без mod_init)
│       └── test_mod_bad_init.c (модуль с mod_init возвращающим ошибку)
├── Makefile             (сборка программы, модуля, библиотеки, тестов)
└── overview.md          (документация)

### Основная программа (kmodlike)

Основная программа может работать в двух режимах:

1. **Режим демона (daemon mode)** - запускается без аргументов:
   - Инициализирует RPC сервер на порту 8888
   - Регистрирует RPC команды: `insmod`, `rmmod`, `help`
   - В основном цикле каждую секунду пытается вызвать функцию `mod_hello()` из загруженного модуля
   - Если модуль не загружен, выводит "module not_loaded"
   - Обрабатывает SIGSEGV от модуля и автоматически выгружает модуль без падения программы

2. **Режим клиента (client mode)** - запускается с аргументами `insmod` или `rmmod`:
   - Работает как RPC клиент
   - Подключается к демону на localhost:8888
   - Отправляет RPC запрос на загрузку/выгрузку модуля
   - Выводит результат и завершается

### Модуль (mod.so)

Динамически загружаемая библиотека (`mod.so`), которая:

- Экспортирует функцию `mod_hello()`, которая печатает "hello world" на экран
- При загрузке (через `__attribute__((constructor))`) запускает отдельный поток
- Через 3 секунды после загрузки намеренно провоцирует SIGSEGV через разыменование NULL указателя

## Файлы проекта

### main.c / main.h
Основная программа с функциями:
- `module_load()` - загрузка модуля через `dlopen()`
  - Проверяет наличие обязательных функций `mod_init()` и `mod_fini()`
  - Вызывает `mod_init()` после успешной загрузки
  - Валидирует минимальный интерфейс модуля перед загрузкой
- `module_unload()` - выгрузка модуля через `dlclose()`
  - Вызывает `mod_fini()` перед выгрузкой для очистки ресурсов
- `module_call_hello()` - вызов функции из модуля
- `module_get_state()` - получение состояния модуля
- `sigsegv_handler()` - обработчик SIGSEGV
- RPC команды: `rpc_insmod_func()`, `rpc_rmmod_func()`

### mod.c / mod.h
Модуль с минимальным интерфейсом (аналогично модулям ядра Linux):
- **Обязательные функции:**
  - `mod_init()` - функция инициализации модуля (аналог `init_module` в ядре)
    - Вызывается явно основной программой после загрузки модуля
    - Возвращает 0 при успехе, отрицательное значение при ошибке
    - Создает поток, который через 3 секунды вызывает SIGSEGV
  - `mod_fini()` - функция деинициализации модуля (аналог `cleanup_module` в ядре)
    - Вызывается явно основной программой перед выгрузкой модуля
    - Завершает все потоки и освобождает ресурсы
- **Опциональные функции:**
  - `mod_hello()` - экспортируемая функция, печатающая "hello world"

### rpc.c / rpc.h
RPC библиотека для обмена командами между клиентом и сервером:
- UDP сокетный интерфейс
- Порт по умолчанию: 8888
- Формат запроса: null-terminated строки

### Makefile
Содержит цели:
- `make bin` - сборка основной программы
- `make mod` - сборка модуля
- `make all` - сборка всего
- `make clean` - очистка

## Использование

### Запуск демона

```bash
./kmodlike
```

Демон запустится и будет слушать RPC запросы на порту 8888.

### Загрузка модуля (через RPC)

```bash
./kmodlike insmod mod.so
```

Эта команда:
1. Запускается как копия программы в режиме RPC клиента
2. Подключается к демону по UDP на localhost:8888
3. Отправляет команду `insmod mod.so`
4. Демон загружает модуль через `dlopen()`
5. Клиент получает ответ и завершается

### Выгрузка модуля (через RPC)

```bash
./kmodlike rmmod mod
```

Аналогично команде `insmod`, но выполняет выгрузку модуля.

## Workflow

### Нормальный сценарий

1. Запуск демона: `./kmodlike`
2. Загрузка модуля: `./kmodlike insmod mod.so`
3. В основном цикле демона каждую секунду вызывается `mod_hello()` и выводится "hello world"
4. Через 3 секунды модуль вызывает SIGSEGV
5. Обработчик SIGSEGV устанавливает флаг
6. В основном цикле обнаруживается флаг, модуль выгружается
7. Демон продолжает работу, выводя "module not_loaded"

### Интеграционный тест

```bash
make clean
make all
./kmodlike insmod mod.so
# Ждем 3 hello world, потом сообщение о выгрузке модуля
./kmodlike insmod mod.so
# Снова ждем hello world
./kmodlike rmmod mod
# Модуль выгружается
```

## Архитектура модулей

### Минимальный интерфейс модуля

Архитектура модулей аналогична модулям ядра Linux. Каждый модуль должен реализовать минимальный интерфейс:

#### Обязательные функции:

1. **`int mod_init(void)`** - функция инициализации
   - Вызывается основной программой после загрузки модуля
   - Должна выполнить всю необходимую инициализацию
   - Возвращает `0` при успехе, отрицательное значение при ошибке
   - Если возвращает ошибку, модуль не считается загруженным

2. **`void mod_fini(void)`** - функция деинициализации
   - Вызывается основной программой перед выгрузкой модуля
   - Должна завершить все потоки и освободить все ресурсы
   - Модуль не будет выгружен, пока эта функция не завершится

#### Опциональные функции:

- **`void mod_hello(void)`** - пример экспортируемой функции
  - Может быть любой набор функций, специфичных для модуля

### Процесс загрузки модуля:

1. Вызов `dlopen()` - загрузка библиотеки в память
2. Проверка наличия обязательных функций через `dlsym()`
3. Вызов `mod_init()` для инициализации модуля
4. Если `mod_init()` вернул ошибку, модуль выгружается

### Процесс выгрузки модуля:

1. Вызов `mod_fini()` для очистки ресурсов
2. Ожидание завершения всех потоков модуля (через `pthread_join()`)
3. Вызов `dlclose()` для выгрузки библиотеки

## Технические детали

### Обработка SIGSEGV

- При получении SIGSEGV устанавливается атомарный флаг `g_sigsegv_received`
- В основном цикле проверяется флаг, и если он установлен, модуль выгружается
- Основная программа не падает, продолжает работу

### Потокобезопасность

- Используется `pthread_mutex_t` для защиты операций с модулем
- Атомарные переменные для флагов состояния
- RPC сервер работает в отдельном потоке
- Модули должны корректно завершать все потоки в `mod_fini()`

### RPC протокол

- UDP сокеты для простоты
- Формат запроса: null-terminated строки (первая - команда, следующие - аргументы)
- Ответ - строка с результатом операции

## Ограничения

- Работает только с одним модулем одновременно
- RPC сервер работает только на localhost
- Нет аутентификации и авторизации в RPC

